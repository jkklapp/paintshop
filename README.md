# paintshop
Paintshop problem solver.

## Features

Good things of this code:

* Modularity: Generation, solving, and optimization are separated to easily extend/improve 
			  code.

* Testability: Unit tests are provided with every module.

* Usability: A command line tool is provided to generate examples and play with them.

Bad things:

There is a known issue when parsing a big test file, with `N ~~ 40` and `M ~~ 40`. This bug 
is being work on, but if you stay away from those limits it should work fine.

## Usage

Every module has its own test module. Run: 

```
$ ./test_all.sh
```

To run all tests.

## main.py

General usage of the `main.py` module:

```
$ python ./main.py -h
usage: main.py [-h] [-i INPUT] [-o OUTPUT] [-c [N_CASES]] [-N [N_COLORS]]
               [-M [N_CUSTOMERS]] [-b] [-s SOLUTION_FILE]
               [-m {matte_minimizer,random_optimizer}]

optional arguments:
  -h, --help            show this help message and exit
  -i INPUT, --input INPUT
                        Read case from a file.
  -o OUTPUT, --output OUTPUT
                        Write output to a file.

Generate:
  -c [N_CASES], --cases [N_CASES]
                        Number of test cases to generate.
  -N [N_COLORS], --colors [N_COLORS]
                        Max number of colors in the case.
  -M [N_CUSTOMERS], --customers [N_CUSTOMERS]
                        Max number of customers in the case

Solve:
  -b, --best            Get always the best solution, as opposed to a random
                        one.

Optimize solution:
  -s SOLUTION_FILE, --solution-file SOLUTION_FILE
                        Solution file generated by solver.
  -m {matte_minimizer,random_optimizer}, --method {matte_minimizer,random_optimizer}
                        Method to use when optmizing
```

## Sample workflow

To generate cases run:

```
$ python ./main.py -c 3 -N 5 -M 5 -o test_file

```

Now we solve the cases:

```
$ python ./main.py -i test_file -o solutions_file
```

This will print to `solutions_file` the first solution found for each case, whether is the best 
or not. To print only the best solutions add the `-b` flag.

Now that we have some solutions, let's improve them using the `optimizer.py` module.

```
$ python ./main.py -i test_file -s solutions_file
```

This will use the `random_optimizer` method. To use the `matte_minimizer` run:

```
$ python ./main.py -i test_file -s solutions_file -m matte_minimizer
```

## Solving

The module `solver.py` implements a solver that uses the cartesian product of the customer 
set to generate all possible solutions. There is some smart logic to remove useless solution 
candidates.

## Optimization Methods

The module `optimizer.py` provides means of improve a solution. The solution provided must 
be valid. This module can be extended to provide more methods.

### Matte minimizer

This strategy generates a 'naive optimal solution', this is, a batch with all colors in glossy variety. Then, it switches from glossy to matte one by one and checks if the solution satisfies. If it does, stops the optimization.

### Random minimizer

This method randomly switches 1s by 0s and viceversa.

### Method discussion

Given the complexity of this problem, a good strategy to get a solution when `N >> 15` and `M >> 15` is to generate a random valid solution and try to optimize it with `matte_minimizer`, rather than compute all solutions with the `solver.py` module. Generally, `matte_minimizer` works better than `random_optimizer`, specially for big solutions say `colors >> 10`. But still, its 
good to have this method as benchmark if you decide to implement a new one.

### Optimization examples

For a generated test case file and a non-optimal solutions file, we invoke the optimizer to 
get better solutions.

```
$ python ./main.py -i test_file -s solutions.test -m matte_minimizer
opt
Skipping case #1  IMPOSSIBLE
For case:
[['4 0', '3 0'], ['2 0', '3 0'], ['1 0', '4 0', '3 0'], ['4 0', '2 1']]
Optimizing solution:  0 1 0 0 ---> 0 0 0 0
Skipping case #3  IMPOSSIBLE
For case:
[['4 1', '5 0', '2 0']]
Optimizing solution:  0 0 0 1 0 0 ---> 0 0 0 0 0 0
For case:
[['1 0', '6 1', '3 0', '4 0', '7 0'], ['1 1', '5 0'], ['5 0'], ['5 0', '6 1'], ['4 0', '2 1'], ['5 1', '7 0'], ['3 0', '2 0', '5 0', '7 0', '1 1', '4 0', '6 0']]
Optimizing solution:  1 0 0 0 0 1 0 ---> 1 0 0 0 0 1 0
```

